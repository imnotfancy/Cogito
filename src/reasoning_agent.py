# src/critique_module/reasoning_agent.py

"""
Defines the base class and specific implementations for reasoning agents
within the critique council.
"""

import os
from abc import ABC, abstractmethod
from typing import Dict, List, Any

# Import reasoning tree logic
from .reasoning_tree import execute_reasoning_tree

# Define the base path for prompts relative to this file's location
# *** ADJUSTED FOR INDEPENDENT MODULE ***
PROMPT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'prompts')) # Assumes prompts is sibling to src

class ReasoningAgent(ABC):
    """
    Abstract base class for a reasoning agent in the critique council.
    Each agent embodies a specific reasoning style.
    """
    def __init__(self, style_name: str):
        """
        Initializes the agent with its style name.

        Args:
            style_name: The name of the reasoning style (e.g., 'Logician').
        """
        self.style = style_name
        # print(f"Initialized agent with style: {self.style}") # Temporary trace removed

    @abstractmethod
    def get_style_directives(self) -> str:
        """Returns the specific directives defining the agent's reasoning style."""
        pass

    async def critique(self, content: str, config: Dict[str, Any]) -> Dict[str, Any]: # Add config, make async
        """
        Generates an initial critique of the content using the agent's style
        and the recursive reasoning tree logic.

        Args:
            content: The text content to be critiqued.

        Returns:
            A dictionary representing the initial critique tree.
            Example: {'agent_style': str, 'critique_tree': dict}
        """
        # print(f"Agent '{self.style}' starting initial critique...") # Temporary trace removed
        style_directives = self.get_style_directives()

        # Call the async reasoning tree function
        critique_tree_result = await execute_reasoning_tree( # Use await
            initial_content=content,
            style_directives=style_directives,
            agent_style=self.style, # Pass style for context/logging in tree function
            config=config # Pass config
        )
        # Handle case where tree generation terminates early (e.g., max depth)
        if critique_tree_result is None:
             critique_tree_result = { # Default empty/terminated structure
            'id': 'root-terminated',
            'claim': f'Critique generation terminated early for {self.style}.',
            'evidence': '',
            'confidence': 0.0,
            'severity': 'N/A',
            'sub_critiques': []
        }

        # print(f"Agent '{self.style}' finished initial critique.") # Temporary trace removed

        return {
            'agent_style': self.style,
            'critique_tree': critique_tree_result
        }

    async def self_critique(self, own_critique: Dict[str, Any], other_critiques: List[Dict[str, Any]], config: Dict[str, Any]) -> Dict[str, Any]: # Add config, make async
        """
        Performs self-critique based on the agent's own initial critique and
        the critiques provided by other council members.

        Args:
            own_critique: The initial critique generated by this agent.
            other_critiques: A list of initial critiques from other agents.

        Returns:
            A dictionary containing adjustments or confirmations based on the self-critique.
            Example: {'agent_style': str, 'adjustments': list[dict]}
        """
        # print(f"Agent '{self.style}' starting self-critique...") # Temporary trace removed
        style_directives = self.get_style_directives()
        other_styles = [c.get('agent_style', 'Unknown') for c in other_critiques]
        # print(f"Agent '{self.style}' considering critiques from: {other_styles}") # Temporary trace removed

        # Placeholder for actual self-critique logic.
        # This might involve generating a new tree based on comparing critiques,
        # or simply adjusting confidence/claims in the original tree.
        # For now, returning simple placeholder adjustments.
        adjustments = []
        own_tree_id = own_critique.get('critique_tree', {}).get('id', 'N/A')
        if own_tree_id != 'root-terminated': # Only add adjustment if initial critique wasn't terminated
            adjustments.append(
                {
                    'target_claim_id': own_tree_id,
                    'confidence_delta': -0.05, # Example adjustment
                    'reasoning': f'Placeholder self-critique adjustment by {self.style}.'
                }
            )

        # print(f"Agent '{self.style}' finished self-critique.") # Temporary trace removed

        return {
            'agent_style': self.style,
            'adjustments': adjustments
        }

# --- Concrete Philosopher Agent Implementations ---

class PhilosopherAgent(ReasoningAgent):
    """Base class for agents loading directives from prompt files."""
    def __init__(self, name: str, prompt_filename: str):
        super().__init__(name)
        self.prompt_filepath = os.path.join(PROMPT_DIR, prompt_filename)
        self._directives_cache: str | None = None # Cache for directives

    def get_style_directives(self) -> str:
        """Loads and returns the directives from the agent's prompt file."""
        if self._directives_cache is None:
            # Check if the adjusted path exists first
            if not os.path.exists(self.prompt_filepath):
                 # Fallback: Try path relative to current file (if prompts is inside src)
                 alt_prompt_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'prompts'))
                 alt_filepath = os.path.join(alt_prompt_dir, os.path.basename(self.prompt_filepath))
                 if os.path.exists(alt_filepath):
                      self.prompt_filepath = alt_filepath
                 else:
                      # print(f"Agent '{self.style}': ERROR - Prompt file not found at {self.prompt_filepath} or {alt_filepath}")
                      self._directives_cache = f"ERROR: Prompt file not found for {self.style}."
                      return self._directives_cache

            try:
                with open(self.prompt_filepath, 'r', encoding='utf-8') as f:
                    self._directives_cache = f.read()
                # print(f"Agent '{self.style}': Directives loaded from {self.prompt_filepath}") # Temporary trace removed
            except FileNotFoundError: # Should be caught by exists check, but keep as safeguard
                # print(f"Agent '{self.style}': ERROR - Prompt file not found at {self.prompt_filepath}") # Keep error logging if desired, or raise
                self._directives_cache = f"ERROR: Prompt file not found for {self.style}."
            except Exception as e:
                # print(f"Agent '{self.style}': ERROR - Failed to read prompt file {self.prompt_filepath}: {e}") # Keep error logging if desired, or raise
                self._directives_cache = f"ERROR: Failed to read prompt file for {self.style}."
        # Ensure return type is string even on error
        return self._directives_cache if self._directives_cache is not None else ""

# --- Specific Philosopher Agents ---

class AristotleAgent(PhilosopherAgent):
    """Critiques based on Aristotelian principles."""
    def __init__(self):
        super().__init__('Aristotle', 'critique_aristotle.txt')

class DescartesAgent(PhilosopherAgent):
    """Critiques based on Cartesian principles."""
    def __init__(self):
        super().__init__('Descartes', 'critique_descartes.txt')

class KantAgent(PhilosopherAgent):
    """Critiques based on Kantian principles."""
    def __init__(self):
        super().__init__('Kant', 'critique_kant.txt')

class LeibnizAgent(PhilosopherAgent):
    """Critiques based on Leibnizian principles."""
    def __init__(self):
        super().__init__('Leibniz', 'critique_leibniz.txt')

class PopperAgent(PhilosopherAgent):
    """Critiques based on Popperian principles."""
    def __init__(self):
        super().__init__('Popper', 'critique_popper.txt')

class RussellAgent(PhilosopherAgent):
    """Critiques based on Russellian principles."""
    def __init__(self):
        super().__init__('Russell', 'critique_russell.txt')
